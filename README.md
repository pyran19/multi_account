# 複数アカウントにおけるレートマッチング最適戦略

<p align="center">
  <img src="https://user-images.githubusercontent.com/placeholder/elo.png" width="400" alt="illustration"/>
</p>

本リポジトリでは、**複数アカウントを保有するプレイヤーが、限られた試合数でどのようにレート戦へ参加すれば最終レート（シーズン終了時に最も高いアカウントのレート）の期待値を最大化できるか**を、理論計算と数値シミュレーションの両面から解析します。

---

## 1. 背景と課題
多くのオンラインゲームでは Elo をベースにしたレーティングが用いられ、シーズン終了時の"瞬間レート"でランキングが決まります。複数アカウントを同時運用する場合、**最も高いレートを持つアカウントだけが順位に反映される**ため、

* どのタイミングでどのアカウントを出すべきか？
* 途中で"打ち止め"にして確定すべきか？

といった戦略が総合レートの期待値に影響します。本プロジェクトはこれを**動的計画法 (DP) による逐次最適化**で厳密に評価し、Monte-Carlo シミュレーションで検証します。

---

## 2. 解析モデル
1. レート変動: 1 試合ごとに固定値 $\pm 16$ 増減。
2. 勝率関数: 線形近似 $p(r)=0.5 - k (r - \mu)$。適正レート $\mu$ に収束するイメージ。
3. 各アカウントは同じ $\mu$ を共有し、初期レートから $N_0$ 試合で近傍に到達後、"揺らぎ"フェーズに入ると仮定。
4. 全アカウントの総試合数に上限 $N$ を設け、途中で打ち切ることも可能。
5. 終了時は最大レートを採用。

詳細な数式は `document/permanent/期待値逐次解法.md` を参照してください。

---

## 3. リポジトリ構成
```
├── document/
│   ├── fleeting/   # アイデアメモ（走り書き）
│   ├── ai/         # 実装計画など自動生成ドキュメント
│   └── permanent/  # 確定仕様・最終レポート
│
└── src/            # 実装コード
    ├── core/       # DP・数式処理
    ├── simulator/  # Monte-Carlo シミュレーション
    ├── mcp_server.py # MCPサーバー
    └── tests/      # pytest
```
- 運用ルールとして、人間の書いた思いつきはまずfleetingに作成、AI生成のドキュメントはdocument/aiに配置する。
- それら二つをまとめて保存用の文章という形で清書や承認したものがpermanentとして格納される。
- 実装の詳細などを参照する時はまずpermanentを探してその記述を優先し、その中にない場合に限って昇格前だとみなしてfleetingやaiフォルダの中の記述を探しにいくという優先度で参照する。

---

## 4. 今後のロードマップ
- [ ] ドキュメント整備
  - [x] 下書き（fleeting）
  - [x] AI による清書（current）
  - [ ] レビュー後 permanent へ昇格
- [x] 期待値 DP モジュール実装
- [x] シミュレーション実装
- [x] 小規模ケースでの検証
- [ ] 大規模実験 & 可視化
- [ ] 考察・レポートまとめ

### ドキュメントのレビューとpermanentへの昇格
一時凍結中の文章はうち消し線
- [ ] AI論文計画
- [ ] 実験予定/ 実験予定2 
- [ ] ~~解析的な理論計算~~
- [ ] 解法の方針
- [ ] 問題意識
- [ ] multi_account_optimization_report
- [x] MCP_server_manual
- [x] 実装メモ

*備考*: 
- 実装メモは「完成」というものがなく常に更新され続けるべきなのでpermanentには上げない。ある程度まとまりが出来たらその部分を切り離す形で新規ファイルをpermanentに作る
  

### 本実験
- [x] 実験計画立案
- [ ] 実験用のプログラム微調整
- [ ] 実験実行
- [x] AIによる実験

## 5. 計算結果の保存と再利用

DP 計算は試合数 `n` とアカウント数 `r` が増えるにつれ指数的に時間が掛かります。
そこで、本リポジトリでは**計算結果をディスクにキャッシュ**し、同じ条件を再度計算する場合に再利用します。

### 5.1 仕組み
1. `src/cli.py` の `dp` サブコマンド、または `src/mcp_server.py` を介した `calculate_dp` ツール実行時、
   - まず `results/cache/n{n}_acc{r}.txt` を探索し、該当するレート列があればその値を読み込みます (再計算しない)。
   - 無ければ通常通り DP を実行し、得られた期待値と最適アクションをファイルへ追記します。
   - `src/core/dp.py` 内では、`CACHE_INTERVAL`（デフォルト50試合）ごとに中間結果もキャッシュファイルに保存されます。
2. これにより **一度計算した状態は永続的にキャッシュ** されるため、次回以降は即時に結果を取得できます。

### 5.2 出力ファイル形式
```
results/cache/n100_acc3.txt
n=100
r=3

account1, account2, account3, expectation, best_action
0, 0, 0, 3, 1
1, 0, 0, 4, 1
1, 1, 0, 5, 1
```
* 先頭 2 行: パラメータ (`n`, `r`)
* 空行
* ヘッダ行
* 以降は `[アカウント毎のレート], 期待値, best_action` を CSV 形式で追記します。
* **全てのレートは整数表現で記録**されます（詳細は「6. レートの整数化」参照）。

### 5.3 使い方
```bash
# 例) 残り 20 試合、アカウント 3 つで全て 1500 スタートの場合
# (初期レートを省略すると、全アカウントがデフォルトの適正レート mu で初期化されます)
python -m src.cli dp --n 20 --accounts 3

# 初期レートを個別に指定する場合 (例: 1500, 1516, 1484)
python -m src.cli dp --n 20 --accounts 3 --initial 1500 1516 1484
```
初回は DP 計算を行い、2 回目以降はキャッシュが利用されます。

## 6. レートの整数化

計算効率と数値安定性のために、内部処理では**レートを整数値**として扱います。

### 6.1 変換方法
実数レート `r` から整数レート `i` への変換：
```
i = round((r - μ) / d)
```
ここで、
- `r`: 実数レート（例: 1500、1516 など）
- `μ`: 適正レート（デフォルト 1500）
- `d`: レート変動幅（デフォルト 16）

整数レートは「適正レートから何回勝ったか」を表す値になります。
例: 1500 → 0, 1516 → 1, 1484 → -1

### 6.2 メリット
1. **キャッシュの効率化**: 微小な数値誤差でキャッシュが効かなくなる問題を防止
2. **メモリ効率**: 実数より整数のほうがメモリ使用量が少ない
3. **計算安定性**: 同じパラメータでの計算結果が常に同一になる

### 6.3 実装詳細
- ユーザー入出力インターフェースは従来通り実数レートを使用
- 内部計算と永続化（キャッシュ）では整数レートを使用
- 変換関数は `src/core/parameters.py` で定義

---

## 7. MCPサーバー連携 (MCP Server Integration)

本リポジトリには、外部のAIエージェントやプランニングツールとの連携を目的としたMCP（Multi-Context Planner）サーバー機能 (`src/mcp_server.py`) が含まれています。
このサーバーは標準入出力（stdio）を介してMCPプロトコルで通信し、本プロジェクトのコア機能である動的計画法（DP）による期待値計算 (`calculate_dp`) やモンテカルロシミュレーション (`run_simulation`) を外部から呼び出すことができます。

サーバーの起動方法や利用可能なツールの詳細な仕様、通信プロトコルの例については、`document/permanent/MCPサーバ利用マニュアル.md` を参照してください。
